<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>%%TITLE%%</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --panel:#ffffff;
      --ink:#111;
      --muted:#6b7280;
      --line:#e5e7eb;
      --accent:#2563eb;
      --accent-weak:#93c5fd;
      --uncertain:#ef4444;
      --chip:#eef2ff;
      --chip-text:#1f2937;
      --shadow:0 1px 2px rgba(0,0,0,0.06), 0 8px 24px rgba(0,0,0,0.06);
      --lane-gap:8px; /* horizontale kolomafstand */
      --v-gap:6px;    /* verticale ruimte binnen groepen */
      --small:12px;
      --body:14px;
      --sticky-top:0;
    }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--ink); font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji"; }

    
    .topbar{
      position:sticky; top:var(--sticky-top); z-index:50;
      border-bottom:1px solid var(--line); background:#fff; box-shadow:none;
    }
    
    /* Summary row (always visible) */
    .topbar-summary{
      list-style:none; /* hide default marker */
      cursor:pointer; user-select:none;
      background:linear-gradient(180deg, #ffffff 0%, #ffffffee 70%, #ffffffcc 100%);
      backdrop-filter: blur(6px);
      border-bottom:1px solid var(--line);
    }
    .topbar-summary::-webkit-details-marker{ display:none; }
    
    .topbar-row{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 20px;
    }
    .title-wrap h1{ margin:0 0 4px; font-size:18px; }
    .title-wrap .muted{ font-size:var(--small); }
    
    
    
    /* Expanded body */
    .topbar-body{ padding:12px 20px 16px; }
    
    /* Chip area: already non-scrolling; keep your existing rule */
    .filters .chips{ max-height:none; overflow:visible; }
    
    /* Optional: compact summary when collapsed */
    .topbar:not([open]) .muted{ display:none; }
    


    .container{ max-width:1100px; margin:0 auto; padding:16px 20px; }
    h1{ margin:0 0 6px; font-size:20px; }
    .muted{ color:var(--muted); font-size:var(--small); }

    .filters{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-top:10px;}
    .filters .chips{
      display:flex; flex-wrap:wrap; gap:8px;
      /* no internal scrolling */
      max-height:none; overflow:visible;
      padding:8px; background:var(--panel); border:1px solid var(--line); border-radius:10px;
    }
    .chip{ display:inline-flex; align-items:center; gap:6px; background:var(--chip); color:var(--chip-text); padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid #e6e9ff; }
    .chip input{ accent-color:var(--accent); }
    .filters .actions{ display:flex; gap:8px; }
    .btn{ border:1px solid var(--line); background:#fff; padding:6px 10px; border-radius:8px; cursor:pointer; }
    .btn.primary{ border-color:var(--accent); color:#fff; background:var(--accent); }
    .legend{ margin-top:8px; font-size:12px; color:var(--muted); display:flex; gap:16px; align-items:center; flex-wrap:wrap;}
    .legend .swatch{ width:12px; height:12px; display:inline-block; border-radius:3px; margin-right:6px; vertical-align:middle; }
    .legend .dashed{ width:16px; height:0; border-top:2px dashed var(--uncertain); display:inline-block; margin-right:6px; }

    main.timeline{ padding:16px 20px 40px; }
    section.day{ background:var(--panel); border:1px solid var(--line); border-radius:12px; box-shadow:var(--shadow); margin:16px auto; padding:0; }
    .date-header{ position:sticky; top:calc(var(--sticky-top) + 54px); background:#fff; border-bottom:1px solid var(--line); padding:10px 14px; z-index:5; display:flex; justify-content:space-between; align-items:center; }
    .date-header h2{ margin:0; font-size:16px; }
    .date-header .count{ color:var(--muted); font-size:12px; }

    .day-body{ padding:12px 14px; display:flex; flex-direction:column; gap:14px; }
    .group{ border:1px solid var(--line); border-radius:10px; padding:10px; background:#fff; }
    .group-header{ font-size:12px; color:var(--muted); margin-bottom:8px; }
    .group-grid{ display:grid; grid-auto-rows:auto; gap:var(--v-gap) var(--lane-gap); }

    .event{
      position:relative;
      padding:8px;
      background:#fff;
      border:1px solid #e6e8ef;
      border-left:4px solid var(--accent);
      border-radius:10px;
      box-shadow:0 2px 6px rgba(0,0,0,0.04);
      overflow:hidden;
      display:flex; flex-direction:column; gap:6px;
    }
    .event.point{ border-left-style:dotted; }
    .event.uncertain{ border-style:dashed; border-color:var(--uncertain); border-left-color:var(--uncertain); }
    .event .time{ font-weight:600; font-size:12px; color:#0f172a; }
    .event .desc{ white-space:pre-wrap; font-size:var(--body); }
    .event .ents{ display:flex; flex-wrap:wrap; gap:6px; }
    .event .ents .e{ background:#f1f5f9; border:1px solid #e2e8f0; border-radius:999px; padding:2px 8px; font-size:11px; color:#334155; }
    .continues{ font-size:11px; color:var(--muted); }

    .no-time{ padding:12px 14px; }
    .no-time h3{ margin:0 0 10px; font-size:13px; color:var(--muted); }
    .no-time .nt-list{ display:flex; flex-direction:column; gap:10px; }
    .no-time .nt-item{ background:#fff; border:1px solid #e6e8ef; border-left:4px solid var(--accent-weak); padding:10px; border-radius:10px; box-shadow:0 1px 3px rgba(0,0,0,0.03); }
    .no-time .nt-item.uncertain{ border-style:dashed; border-color:var(--uncertain); border-left-color:var(--uncertain); }
    .no-time .nt-item .desc{ white-space:pre-wrap; }
    .no-time .nt-item .ents{ margin-top:6px; display:flex; flex-wrap:wrap; gap:6px; }
    .no-time .nt-item .ents .e{ background:#f1f5f9; border:1px solid #e2e8f0; border-radius:999px; padding:2px 8px; font-size:11px; color:#334155; }

    .undated{ background:var(--panel); border:1px solid var(--line); border-radius:12px; box-shadow:var(--shadow); margin:24px auto; padding:14px; }
    .undated h2{ margin:0 0 10px; font-size:16px; }
    .table{ width:100%; border-collapse:collapse; }
    .table th, .table td{ text-align:left; vertical-align:top; border-bottom:1px solid var(--line); padding:10px 6px; font-size:14px; }
    .table th{ font-weight:600; color:#111827; }
    .badge{ display:inline-block; font-size:11px; padding:2px 6px; border-radius:6px; border:1px solid #fde68a; background:#fffbeb; color:#92400e; }

    .chip[data-color]{
      border-color: currentColor;
    }
    .chip[data-color] input{ accent-color: currentColor; }
    
    /* event entity badges get colored background/border */
    .event .ents .e[data-color]{
      background: var(--pill-bg, #f1f5f9);
      border-color: currentColor;
    }
           

    .hidden{ display:none !important; }
  </style>
</head>
<body>
    <details class="topbar" id="pageTopbar" open>
      <summary class="topbar-summary">
        <div class="container topbar-row">
          <div class="title-wrap">
            <h1>%%TITLE%%</h1>
            <div class="muted">Per-dag gestapelde weergave met kolommen voor overlappende events. Filter op entiteit hieronder.</div>
          </div>          
        </div>
      </summary>
    
      <div class="container topbar-body">
        <div class="filters">
          <div class="actions">
            <button class="btn" id="selectAll">Selecteer alles</button>
            <button class="btn" id="clearAll">Wis selectie</button>
          </div>
          <div class="chips" id="entityChips" aria-label="Filter op entiteit"></div>
        </div>
    
        <div class="legend">
          <span><span class="swatch" style="background:var(--accent); opacity:.3; border:1px solid var(--accent);"></span> Event (met duur)</span>
          <span><span class="swatch" style="background:#fff; border:2px dotted var(--accent);"></span> Event (alleen starttijd)</span>
          <span><span class="dashed"></span> Onzeker tijdstip</span>
        </div>
      </div>
    </details>


  <main class="timeline container" id="timelineRoot"></main>

  <section class="container undated" id="undatedSection">
    <h2>Overige gebeurtenissen zonder datum/tijd</h2>
    <table class="table" id="undatedTable">
      <thead><tr><th>Gebeurtenis</th><th>Entiteiten</th><th>Zekerheid</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <script>
    // ------------------ DATA ------------------
    const DATA = %%DATA%%;
    const MIN_EVENT_MIN = %%MIN_EVENT_MIN%%; // gebruikt om 'punt'events een minimale duur te geven
    const ALL_ENTITIES = %%ALL_ENTITIES_JSON%%;

    // ------------------ UTIL ------------------
    const slugify = (t) => (t||"").toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9\-._~]/g,'');
    const by = (k) => (a,b) => a[k] < b[k] ? -1 : a[k] > b[k] ? 1 : 0;

    function groupBy(arr, keyFn){
      const m = new Map();
      for(const item of arr){
        const k = keyFn(item);
        if(!m.has(k)) m.set(k, []);
        m.get(k).push(item);
      }
      return m;
    }

    function asMinutes(v){                      // finite -> number, else null
      return Number.isFinite(v) ? v : null;
    }
    function asMinutesOr(v, fallback){          // finite -> number, else fallback
      return Number.isFinite(v) ? v : fallback;
    }


    function isUnknownTime(ev){
      // unknown if both start_m and end_m are not finite numbers
      return !Number.isFinite(ev.start_m) && !Number.isFinite(ev.end_m);
    }

    function makePalette(n){
      // Distinct HSLs using golden-angle spacing
      const colors = [];
      const golden = 137.508;
      for(let i=0;i<n;i++){
        const h = (i * golden) % 360;
        const s = 68;  // sat
        const l = 48;  // light
        colors.push(`hsl(${h.toFixed(1)}, ${s}%, ${l}%)`);
      }
      return colors;
    }
    
    function hexToRgba(hexOrHsl, alpha){
      // crude converter for hsl(...) or hex -> rgba() just to make pill bg translucent
      if(/^hsl/i.test(hexOrHsl)){
        // parse hsl(h, s%, l%)
        const m = hexOrHsl.match(/hsl\(([^,]+),\s*([^%]+)%,\s*([^%]+)%\)/i);
        if(!m) return `rgba(0,0,0,${alpha})`;
        let h = parseFloat(m[1]); let s = parseFloat(m[2])/100; let l = parseFloat(m[3])/100;
        // hsl -> rgb
        const a = s * Math.min(l, 1-l);
        const f = (n)=>{
          const k = (n + h/30) % 12;
          const c = l - a * Math.max(-1, Math.min(k-3, 9-k, 1));
          return Math.round(255*c);
        };
        return `rgba(${f(0)},${f(8)},${f(4)},${alpha})`;
      }
      // hex #rrggbb
      const m = hexOrHsl.replace('#','');
      const r = parseInt(m.slice(0,2),16), g = parseInt(m.slice(2,4),16), b = parseInt(m.slice(4,6),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    
    function buildEntityColorMap(entities){
      const sorted = entities.slice().sort((a,b)=> a.localeCompare(b, 'nl', {sensitivity:'base'}));
      const palette = makePalette(sorted.length);
      const map = new Map();
      sorted.forEach((name, idx)=>{
        const slug = slugify(name);
        const color = palette[idx];
        map.set(slug, { color, pillBg: hexToRgba(color, 0.12) });
      });
      return map;
    }



    function formatTime(m){
      if(!Number.isFinite(m)) return '—';
      const h = Math.floor(m/60).toString().padStart(2,'0');
      const mm = (m%60).toString().padStart(2,'0');
      return `${h}:${mm}`;
    }

    
    function normalizeInterval(ev){
      const s = asMinutes(ev.start_m);
      const base = (s ?? 0);
      const e = asMinutesOr(ev.end_m, base + MIN_EVENT_MIN);
      return { _start: base, _end: e };
    }




    function assignLanesInGroup(groupEvents){
      const E = groupEvents.map(ev => {
        const t = normalizeInterval(ev);
        return { ...ev, _start: t._start, _end: t._end };
      }).sort((a,b)=> (a._start - b._start) || (a.row_order - b.row_order));

      const lanesEnd = [];
      let maxLanes = 0;
      for(const ev of E){
        let placed = false;
        for(let li=0; li<lanesEnd.length; li++){
          if(ev._start >= lanesEnd[li]){
            ev._lane = li; lanesEnd[li] = ev._end; placed = true; break;
          }
        }
        if(!placed){ ev._lane = lanesEnd.length; lanesEnd.push(ev._end); }
        maxLanes = Math.max(maxLanes, lanesEnd.length);
      }
      for(const ev of E){
        const idx = groupEvents.findIndex(x => x.seg_id === ev.seg_id);
        if(idx>=0){ groupEvents[idx]._lane = ev._lane; }
      }
      return maxLanes;
    }

    function groupByOverlap(dayEvents){
      if(!dayEvents.length) return [];
    
      // Separate known-time vs unknown-time
      const known = [];
      const unknown = [];
      for(const ev of dayEvents){
        if(isUnknownTime(ev)) unknown.push(ev);
        else known.push(ev);
      }
    
      const groups = [];
    
      // Build overlap groups for known-time events
      if(known.length){
        const sorted = known.slice().sort((a,b)=>{
          const na = normalizeInterval(a), nb = normalizeInterval(b);
          return (na._start - nb._start) || (a.row_order - b.row_order);
        });
    
        let cur = { events: [], start: -1, end: -1 };
        for(const ev of sorted){
          const { _start, _end } = normalizeInterval(ev);
          if(cur.events.length === 0){
            cur.events.push(ev); cur.start = _start; cur.end = _end;
          } else {
            if(_start < cur.end){
              cur.events.push(ev);
              cur.end = Math.max(cur.end, _end);
            } else {
              groups.push(cur);
              cur = { events:[ev], start:_start, end:_end };
            }
          }
        }
        if(cur.events.length) groups.push(cur);
      }
    
      // Append a final “unknown” group (if any)
      if(unknown.length){
        // Keep source order for unknowns
        unknown.sort((a,b)=> a.row_order - b.row_order);
        groups.push({ events: unknown, start: null, end: null, unknown: true });
      }
    
      return groups;
    }


    function timeWindowLabel(startMin, endMin, isUnknown=false){
      if(isUnknown) return 'Tijd onbekend';
      return `${formatTime(startMin)} – ${formatTime(endMin)}`;
    }


    // ------------------ RENDER ------------------
    const root = document.getElementById('timelineRoot');
    const undatedTBody = document.querySelector('#undatedTable tbody');
    const undatedSection = document.getElementById('undatedSection');

    const chipsWrap = document.getElementById('entityChips');
    const ENTITY_COLORS = buildEntityColorMap(ALL_ENTITIES);
    
    function buildEntityChips(){
      chipsWrap.innerHTML = '';
      // alphabetize for display (regardless of Python frequency order)
      const names = ALL_ENTITIES.slice().sort((a,b)=> a.localeCompare(b, 'nl', {sensitivity:'base'}));
      for(const name of names){
        const slug = slugify(name);
        const col = ENTITY_COLORS.get(slug)?.color || '#2563eb';
        const id = 'ent-' + slug;
        const chip = document.createElement('label');
        chip.className = 'chip';
        chip.dataset.color = col;
        chip.style.color = col;  // use currentColor for border + checkbox accent
        chip.innerHTML = `<input type="checkbox" checked data-slug="${slug}" id="${id}"><span>${name}</span>`;
        chipsWrap.appendChild(chip);
      }
    }
    buildEntityChips();


    const byDateTimed = groupBy(DATA.timed, d => d.date);
    const byDateNoTime = groupBy(DATA.date_only, d => d.date);
    const allDates = Array.from(new Set([...byDateTimed.keys(), ...byDateNoTime.keys()])).sort();

    const daySections = new Map();

    function buildDayShell(dateIso){
      const section = document.createElement('section');
      section.className = 'day';

      const header = document.createElement('div');
      header.className = 'date-header';

      const title = document.createElement('h2');
      const sample = (byDateTimed.get(dateIso) && byDateTimed.get(dateIso)[0]) || (byDateNoTime.get(dateIso) && byDateNoTime.get(dateIso)[0]);
      const dateDisplay = sample ? sample.date_display : dateIso;
      title.textContent = dateDisplay;

      const count = document.createElement('div');
      count.className = 'count';
      count.textContent = '';

      header.appendChild(title);
      header.appendChild(count);

      const body = document.createElement('div');
      body.className = 'day-body';

      // Below: "no time" container
      const noTime = document.createElement('div');
      noTime.className = 'no-time';
      const h3 = document.createElement('h3');
      h3.textContent = 'Zonder tijd (volgorde uit bron)';
      noTime.appendChild(h3);
      const list = document.createElement('div');
      list.className = 'nt-list';
      noTime.appendChild(list);

      section.appendChild(header);
      section.appendChild(body);
      section.appendChild(noTime);

      section._refs = { count, body, list };
      section.dataset.date = dateIso;
      return section;
    }

    function renderTimedForDate(dateIso){
      let section = daySections.get(dateIso);
      if(!section){
        section = buildDayShell(dateIso);
        daySections.set(dateIso, section);
        root.appendChild(section);
      } else {
        section._refs.body.innerHTML = '';   // clear the body only
      }
    
      const dayEvents = (byDateTimed.get(dateIso) || []).slice();
      if(dayEvents.length === 0) return;
    
      const groups = groupByOverlap(dayEvents);
    
      for(const g of groups){
        // lanes: only compute for known-time groups
        const lanes = g.unknown ? 1 : assignLanesInGroup(g.events);
    
        const wrap = document.createElement('div');
        wrap.className = 'group';
    
        const gh = document.createElement('div');
        gh.className = 'group-header';
        gh.textContent = timeWindowLabel(g.start, g.end, !!g.unknown);
        wrap.appendChild(gh);
    
        const grid = document.createElement('div');
        grid.className = 'group-grid';
        grid.style.gridTemplateColumns = `repeat(${lanes}, 1fr)`;
        wrap.appendChild(grid);
    
        for(const ev of g.events){
          const isPoint = !ev.has_duration;
    
          const el = document.createElement('div');
          el.className = 'event' + (isPoint ? ' point' : '') + ((ev.certain===false) ? ' uncertain' : '');
          el.dataset.entities = (ev.entity_slugs || []).join(',');
    
          // unknown-time -> first column
          const laneIdx = g.unknown ? 0 : (ev._lane ?? 0);
          el.style.gridColumn = (laneIdx + 1).toString();
    
          // color by first entity
          const firstSlug = (ev.entity_slugs && ev.entity_slugs[0]) || null;
          if(firstSlug && ENTITY_COLORS.has(firstSlug)){
            el.style.borderLeftColor = ENTITY_COLORS.get(firstSlug).color;
          }
    
          // time label
          const hasStart = Number.isFinite(ev.start_m);
          const timeStr = hasStart
            ? (ev.end_label ? `${ev.start_label}–${ev.end_label}` : `${ev.start_label}`)
            : 'tijd onbekend';
    
          const timeDiv = document.createElement('div');
          timeDiv.className = 'time';
          timeDiv.textContent = (ev.certain===false ? '± ' : '') + timeStr;
    
          const descDiv = document.createElement('div');
          descDiv.className = 'desc';
          descDiv.textContent = ev.desc || '';
    
          const ents = document.createElement('div');
          ents.className = 'ents';
          for(const name of (ev.entities||[])){
            const s = document.createElement('span');
            s.className = 'e';
            const slug = slugify(name);
            const colPack = ENTITY_COLORS.get(slug);
            if(colPack){
              s.dataset.color = colPack.color;
              s.style.color = colPack.color;
              s.style.setProperty('--pill-bg', colPack.pillBg);
            }
            s.textContent = name;
            ents.appendChild(s);
          }
    
          if(ev.continues_prev){
            const up = document.createElement('div');
            up.className = 'continues';
            up.textContent = '↥ vervolg van vorige dag';
            el.appendChild(up);
          }
          el.appendChild(timeDiv);
          el.appendChild(descDiv);
          if((ev.entities||[]).length) el.appendChild(ents);
          if(ev.continues_next){
            const dn = document.createElement('div');
            dn.className = 'continues';
            dn.textContent = '↧ gaat door naar volgende dag';
            el.appendChild(dn);
          }
    
          grid.appendChild(el);
        }
    
        section._refs.body.appendChild(wrap);
      }
    }


    function renderNoTimeForDate(dateIso){
      const section = daySections.get(dateIso);
      if(!section) return;
      const list = section._refs.list;
      list.innerHTML = '';

      const evs = (byDateNoTime.get(dateIso) || []).slice().sort((a,b)=> a.row_order - b.row_order);
      if(!evs.length){
        section.querySelector('.no-time').classList.add('hidden');
        return;
      }
      section.querySelector('.no-time').classList.remove('hidden');

      for(const ev of evs){
        const item = document.createElement('div');
        item.className = 'nt-item' + ((ev.certain===false) ? ' uncertain' : '');
        item.dataset.entities = (ev.entity_slugs || []).join(',');

        const desc = document.createElement('div');
        desc.className = 'desc';
        desc.textContent = ev.desc || '';
        item.appendChild(desc);

        if((ev.entities||[]).length){
          const ents = document.createElement('div');
          ents.className = 'ents';
          for(const name of (ev.entities||[])){
            const s = document.createElement('span');
            s.className = 'e'; s.textContent = name; ents.appendChild(s);
          }
          item.appendChild(ents);
        }

        if(ev.certain===false){
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = 'Onzeker';
          item.appendChild(badge);
        }

        list.appendChild(item);
      }
    }

    function renderUndated(){
      undatedTBody.innerHTML = '';
      for(const ev of DATA.undated){
        const tr = document.createElement('tr');
        tr.dataset.entities = (ev.entity_slugs || []).join(',');
        const td1 = document.createElement('td'); td1.textContent = ev.desc || '';
        const td2 = document.createElement('td'); td2.textContent = (ev.entities||[]).join(', ');
        const td3 = document.createElement('td');
        if(ev.certain===false){ td3.innerHTML = '<span class="badge">Onzeker</span>'; }
        else { td3.textContent = ev.certain===true ? 'Zeker' : ''; }
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        undatedTBody.appendChild(tr);
      }
      if(!DATA.undated.length){ undatedSection.classList.add('hidden'); }
      else { undatedSection.classList.remove('hidden'); }
    }

    for(const d of allDates){
      renderTimedForDate(d);
      renderNoTimeForDate(d);
    }
    renderUndated();

    function updateDayCounts(){
      for(const d of allDates){
        const sec = daySections.get(d);
        if(!sec || !sec._refs) continue;
        const visibleTimed = sec.querySelectorAll('.group .event:not(.hidden)').length;
        const visibleNoTime = sec.querySelectorAll('.no-time .nt-item:not(.hidden)').length;
        const total = visibleTimed + visibleNoTime;
        sec._refs.count.textContent = total ? `${total} gebeurtenis${total>1?'sen':''}` : '—';
      }
    }
    updateDayCounts();

    // ------------------ FILTERING ------------------
    function selectedEntitySlugs(){
      const inputs = chipsWrap.querySelectorAll('input[type=checkbox]');
      const active = [];
      for(const inp of inputs){ if(inp.checked) active.push(inp.dataset.slug); }
      return new Set(active);
    }

    function applyFilter(){
      const selected = selectedEntitySlugs();
      const useFilter = selected.size > 0 && selected.size < ALL_ENTITIES.length;

      for(const sec of daySections.values()){
        sec.querySelectorAll('.group .event').forEach(el=>{
          if(!useFilter){ el.classList.remove('hidden'); return; }
          const ent = (el.dataset.entities||'').split(',').filter(Boolean);
          const show = ent.length===0 ? false : ent.some(s => selected.has(s));
          el.classList.toggle('hidden', !show);
        });
        sec.querySelectorAll('.no-time .nt-item').forEach(el=>{
          if(!useFilter){ el.classList.remove('hidden'); return; }
          const ent = (el.dataset.entities||'').split(',').filter(Boolean);
          const show = ent.length===0 ? false : ent.some(s => selected.has(s));
          el.classList.toggle('hidden', !show);
        });
      }

      undatedTBody.querySelectorAll('tr').forEach(tr=>{
        if(!useFilter){ tr.classList.remove('hidden'); return; }
        const ent = (tr.dataset.entities||'').split(',').filter(Boolean);
        const show = ent.length===0 ? false : ent.some(s => selected.has(s));
        tr.classList.toggle('hidden', !show);
      });

      updateDayCounts();
    }

    chipsWrap.addEventListener('change', applyFilter);
    document.getElementById('selectAll').addEventListener('click', ()=>{
      chipsWrap.querySelectorAll('input[type=checkbox]').forEach(i => i.checked = true);
      applyFilter();
    });
    document.getElementById('clearAll').addEventListener('click', ()=>{
      chipsWrap.querySelectorAll('input[type=checkbox]').forEach(i => i.checked = false);
      applyFilter();
    });

    applyFilter();
  </script>
</body>
</html>